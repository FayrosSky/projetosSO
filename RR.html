<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        function criar_linha() {
            document.getElementById("tarefas") //referencia o body
            let t = document.getElementById("tarefas") // temos t que é referencia a tarefas
            document.createElement("tr") //Criamos um elemento. Ele existe, mas ainda não tá no documento
            let tr = document.createElement("tr") //Esse elemento tr existe, mas ainda não está no documento,apenas adicionamos ele a uma variável. 
            t.append(tr) //O tr tava só flutuando... fazendo o append estamos amarrando o tr como o último filho do body.
            //O innerHTML nos poupa de ficar dando vários appends
            tr.innerHTML = `<td>   
                        <input type="number">  
                    </td>
                    <td>
                        <input type="number"> 
                    </td>
                    <td>
                        <button onclick='apagar_linha(this)'>
                            -
                        </button>
                    </td>`
        }
        function apagar_linha(botao) {
            botao.parentElement.parentElement.remove()
        }

        function mostrar_resultado_RR() {
            let tarefas = []
            let tbody = document.getElementById('tarefas')  // uma função que precisamos chamar passando um parâmetro string como id. Isso retorna um objeto com referência ao tbody
            for (let item of tbody.children) {
                //console.log(item.querySelector()) //a função querySelector aceitar uma regra do css e nesse caso ele vai retornar o primeiro elemento filho de item que bater com a regra é assim que o css funciona, se quisessemos  o elemento tarefa a gente passava a função queryselector("#tarefas"), e ele retorna o próprio elemento tarefas dessa forma.

                let inputs = item.querySelectorAll('input')

                let ingresso = inputs[0].value
                let Duração = inputs[1].value

                tarefas.push({ ing: ingresso, dur: Duração }) // estamos criando um objeto com {}, e dentro do objeto podemos podemos definir quais os atributos(no caso ing e dur) desse objeto irão ser criados



            }
            console.log({ tarefas })
            executar_RR(tarefas)    //Recebe os inputs e processa-os const input = [
            /* [{"dur": 100, "ing": 100},
            {"dur": 200, "ing": 40},
            {"dur": 3400, "ing": 440},
             ]
        
        [
            {tarefa: "t4", tempo: 1},
            {tarefa: "t4", tempo: 1},
            {tarefa: "t2", tempo: 1},
            {tarefa: "t4", tempo: 1},
            {tarefa: "t2", tempo: 1},
            {tarefa: "t3", tempo: 1},
        ]
         */

        }
        function executar_RR(tarefas) {
            const input = [
                { "dur": 4, "ing": 4 },
                { "dur": 2, "ing": 1 },
                { "dur": 5, "ing": 3 },
                { "dur": 3, "ing": 0}
            ]

            //Variável que vai guardar o índice da tarefa de menor ingresso
            let indice_menor = 0;

            for (let i = 1; i < input.length; i++) {
                if (input[i].ing < input[indice_menor].ing) {
                    indice_menor = i;
                }
            }

            //O tempo máximo que cada tarefa pode ser executada por vez
            const quantum = 1   

            //A fila atual de tarefas que muda ao longo da execução
            let list = []   
            list.push(indice_menor) //colocando a primeira tarfa a ser executa na lista que ordena as tarefas a serem executadas

            let tempo = 0

            let output = []  //Definindo o array de output

            while(true){
                //Calcula quanto tempo a gente vai executar a próxima tarefa
                let menor = Math.min(quantum, input[list[0]].dur)  //nos retorna o menor valor dos argumentos

                //Deduzindo do tempo de duração que foi executado
                input[list[0]].dur -=  menor

                //Executar, o output são os que foram executados, é tipo um relatório das tarefas que foram executadas
                output.push({ tarefa: list[0], tempo: menor })
                //Definindo o avanço do tempo que vai útil pra ser usado para identificar as tarefas que ingressaram
                let comeco = tempo
                tempo += menor
                let fim = tempo

                //Colocar a tarefa que acabou de ser executada no fim da fila.
                variavel_removida = list.shift()

                if(input[variavel_removida].dur != 0){
                    list.push(variavel_removida)
                }

                indices_tarefas_ingressaram = []

                //Adicionando as tarefas que ingressaram em um vetor vazio.
                for (let i = 0; i < input.length; i++) {
                    if (comeco < input[i].ing && fim >= input[i].ing) {
                        indices_tarefas_ingressaram.push(i)
                    }
                }
                //Ordenando as tarefas por ordem de ingresso
                indices_tarefas_ingressaram.sort((a, b) => input[a].ing - input[b].ing) //Ordenando não os índices, mas sim os valors dos ingressos
                list.push(...indices_tarefas_ingressaram)
                console.log(list)

                if(list.length === 0){
                    break
                }
                
            }
            console.log(output)
            


        }

    </script>
</head>

<body>
    <table>
        <thead>
            <tr> <!-- linha inteira-->
                <th> <!-- uma célula do cabeçalho do input-->
                    Ingresso |
                </th>
                <th>
                    Duração |
                </th>
                <th>
                    botões
                </th>
            </tr>
        </thead>
        <tbody id="tarefas">
            <tr>
                <td> <!-- td ou th podemos colocarmos ambos no mesmo lugar a única diferença é a estilização do th-->
                    <input type="number"> <!-- th é uma célula e o td também -->
                </td>
                <td>
                    <input value="666" type="number"> <!-- th é uma célula e o td também -->
                </td>
                <td>
                    <button onclick="apagar_linha(this)">
                        -
                    </button>
                </td>
            </tr>
            <tr>
                <td>
                    <input value="333" type="number"> <!-- th é uma célula e o td também -->
                </td>
                <td>
                    <input value="555" type="number"> <!-- th é uma célula e o td também -->
                </td>
                <td>
                    <button onclick="apagar_linha(this)">
                        -
                    </button>
                </td>
            </tr>
        </tbody>
        <tfoot>
            <tr>
                <td>
                    <button onclick="criar_linha()">
                        <!-- estamos chamando a função usando o onclick. Dentro do onclick usamos js normal, qualquer comando-->
                        Adicionar tarefa

                    </button>
                </td>
                <td>

                </td>
                <td>

                </td>
            </tr>
        </tfoot>
    </table>
    <button onclick="mostrar_resultado_RR()">
        executar
    </button>

</body>

</html>